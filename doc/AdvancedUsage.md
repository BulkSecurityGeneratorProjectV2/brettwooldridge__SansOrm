# Advanced Usage

Here we're going to go through ```OrmElf``` and ```SqlClosureElf``` method by method, with examples.

Going back to the SQL on the main page, and adding some here:
```SQL
CREATE TABLE customer (
   customer_id INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY,
   last_name VARCHAR(255),
   first_name VARCHAR(255),
   email VARCHAR(255)
);

CREATE TABLE product (
   product_number VARCHAR(64),
   description VARCHAR(255),
   weight_grams DECIMAL(7,2)
);

CREATE TABLE order (
   order_id INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY,
   customer_id INTEGER NOT NULL,
   CONSTRAINT order_cust_fk FOREIGN KEY (customer_num) REFERENCES customer (customer_num)
);

CREATE TABLE order_items (
   order_id INTEGER NOT NULL,
   product_number VARCHAR(64),
   item_count INTEGER NOT NULL,
   CONSTRAINT item_order_fk FOREIGN KEY (order_id) REFERENCES order (order_id),
   CONSTRAINT item_product_fk FOREIGN KEY (product_key) REFERENCES product (product_key)
);
```
One of the basic tenents of SansOrm is _SQL-first_ development.  If your application has any hope of scaling, it is
essential that the database schema be _correct_ and completely ignore whatever you might end up doing on the Java-side
to map objects onto it.

### ```OrmElf.statementToObject``` and ```OrmElf.resultSetToObject```
Full signature: ```T resultSetToObject(ResultSet resultSet, T target) throws SQLException```  
Full signature: ```T statementToObject(PreparedStatement stmt, Class<T> clazz, Object... args) throws SQLException```

You don't necessarily have to have a one-to-one mapping between Java classes and tables, in fact it may be rare that
you do.  You can synthesize a class completely from whole cloth.  Take for example a class used to display an order 
summary.  Let's pull a few more tricks here...
```Java
public class OrderSummary {
   @Column(name = "order_id")
   private int orderId;

   @Column(name = "full_name")
   private String fullName;

   @Column(name = "total_items")
   private int itemCount;
}
```
Notice this class has no ```@Table``` annotation because it does not map to a specific table.  Also, notice that
```full_name``` does not map to any existing column name in the tables, neither ```total_items```.  Using the ```OrmElf```
we can populate it like so:
```Java
public OrderSummary getOrderSummary(final int orderId) {
   return new SqlClosure<OrderSummary>() {
      public OrderSummary execute(Connection connection) {
         PreparedStatement pstmt = connection.prepareStatement(
            "SELECT order_id, first_name + ' ' + last_name AS full_name, SUM(oi.item_count) AS total_itmes " +
            "FROM order o " +
            "JOIN customer c ON c.customer_id = o.customer_id " +
            "JOIN order_items oi ON oi.order_id = o.order_id " +
            "WHERE o.order_id = ?");
         return OrmElf.statementToObject(pstmt, OrderSummary.class, orderId);
      }
   }.execute();
}
```
The ```OrmElf``` will take the column names returned from the query and find the matching class members by their
annotations, and populate the object for you.

It is important to note that ```OrderSummary``` as an entity cannot be inserted or updated to the database.  And we think
it's _a positive_, not a negative, that you can see the SQL right in the code; and developers maintaining and changing your code will
appreciate it too.

### ```OrmElf.objectById```
Full signature: ```T objectById(Connection connection, Class<T> clazz, Object... args) throws SQLException```
